(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{418:function(t,a,s){"use strict";s.r(a);var e=s(27),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_07장-서비스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_07장-서비스"}},[t._v("#")]),t._v(" 07장 서비스")]),t._v(" "),s("ABG"),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"서비스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#서비스"}},[t._v("#")]),t._v(" 서비스")]),t._v(" "),s("ul",[s("li",[t._v("파드는 컨트롤러가 관리하므로 한군데에 고정해서 실행되지 않고, 클러스터 안을 옮겨다니는데 이 과정에서 노드가 변경되기도 하고 클러스터 안 파드의 IP가 변경되기도 함")]),t._v(" "),s("li",[s("strong",[t._v("쿠버네티스 서비스는 위처럼 동적으로 변하는 파드들에 고정적으로 접근할 때 사용")])]),t._v(" "),s("li",[t._v("서비스는 주로 L4 영역(전송계층)에서 통신할 때 사용됨")])]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"서비스-타입"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#서비스-타입"}},[t._v("#")]),t._v(" 서비스 타입")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("ClustserIP")])]),t._v(" "),s("ul",[s("li",[t._v("기본 서비스 타입이며, 쿠버네티스 클러스터 안에서만 사용 가능함")]),t._v(" "),s("li",[t._v("클러스터 안 노드나 파드에서는 ClusterIP를 이용해서 서비스에 연결된 파드에 접근")]),t._v(" "),s("li",[t._v("클러스터 외부에서 이용 불가")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("NodePort")])]),t._v(" "),s("ul",[s("li",[t._v("서비스 하나에 모든 노드의 지정된 포트를 할당")]),t._v(" "),s("li",[t._v("노드에 상관없이 서비스에 지정된 포트 번호만 사용하면 파드에 접근 가능")]),t._v(" "),s("li",[t._v("클러스터 외부에서 접근 가능")]),t._v(" "),s("li",[t._v("자동으로 실행되고 있는 파드로 연결해주는 특징이 있음")]),t._v(" "),s("li",[t._v("클러스터 외부에서 클러스터 안 파드로 접근하는 가장 간단한 방법")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("LoadBalancer")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("쿠버네티스를 지원하는 로드밸런서 장비에서 사용")])]),t._v(" "),s("li",[s("p",[t._v("로드밸런서와 파드를 연결한 후 해당 로드밸런서의 IP를 이용해 클러스터 외부에서 파드에 접근 가능하도록함")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("kubectl get service")]),t._v(" 명령으로 서비스 상태를 확인하면 EXTERNAL-IP 항목에 외부에서 파드에 접근할 수 있는 로드밸런서 IP 표시")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("ExternalName")])]),t._v(" "),s("ul",[s("li",[t._v("서비스를 .spec.externalName 필드에 설정한 값과 연결")]),t._v(" "),s("li",[t._v("클러스터 안에서 외부에 접근할 때 주로 사용")]),t._v(" "),s("li",[t._v("이 서비스로 클러스터 외부에 접근하면 설정해둔 CNAME값을 이용해 클러스터 외부에 접근 가능")]),t._v(" "),s("li",[t._v("외부에 접근할 때 사용하는 값이므로 설정할 때 셀렉터(.spec.selector 필드)가 필요 없음")])])])]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"서비스-사용하기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#서비스-사용하기"}},[t._v("#")]),t._v(" 서비스 사용하기")]),t._v(" "),s("h3",{attrs:{id:"기본적인-설정"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#기본적인-설정"}},[t._v("#")]),t._v(" 기본적인 설정")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Service\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" my"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("service\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ClusterIP "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 서비스 타입 설정 (default: ClusterIP)")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterIP")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 10.0.10.10 "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 설정하지 않으면 자동으로 IP 설정")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("selector")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("app")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" MyApp "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 서비스와 연결한 파드에 설정한 .labes 필드 값 설정")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 서비스에서 한꺼번에 포트 여러 개를 외부에 제공할 때는 하위에 필드값으로 설정")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("protocol")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" TCP\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("port")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("targetPort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9376")]),t._v("\n")])])]),s("h3",{attrs:{id:"관련-명령어"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#관련-명령어"}},[t._v("#")]),t._v(" 관련 명령어")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 자세한 서비스 정보 조회")]),t._v("\n$ kubectl describe "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("service")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("서비스 이름"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 현재 실행 중인 파드들의 IP 확인")]),t._v("\n$ kubectl get pods -o wide\n")])])]),s("h3",{attrs:{id:"netshoot-컨테이너-활용하기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#netshoot-컨테이너-활용하기"}},[t._v("#")]),t._v(" netshoot 컨테이너 활용하기")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("ClusterIP는 클러스터 내부에서만 접근할 수 있어서 간단한 테스트를 하기위해서는 같은 클러스터 안에 컨테이너를 하나 띄워야하는데, 이때 netshoot 컨테이너를 활용하여 쉽게 테스트 가능")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 컨테이너, 파드 생성 및 실행")]),t._v("\n$ kubectl run -it --generator"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("run-pod/v1 --image"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("nicolaka/netshoot --overrides"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('\'{"spec": {"nodeSelector": {"kubernetes.io/hostname": "{워커명}" }}}\'')]),t._v(" netshoot - "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bash")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 서비스 생성")]),t._v("\n$ kubectl expose deployment hello-kube --type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("NodePort --name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("hello-kube-service\n")])])])])]),t._v(" "),s("h4",{attrs:{id:"netshoot-컨테이너"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#netshoot-컨테이너"}},[t._v("#")]),t._v(" netshoot 컨테이너")]),t._v(" "),s("ul",[s("li",[t._v("네트워크 문제 추적을 위해 필요한 여러가지 도구를 포함한 별도의 컨테이너")])]),t._v(" "),s("h4",{attrs:{id:"활용-스텝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#활용-스텝"}},[t._v("#")]),t._v(" 활용 스텝")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ kubectl run -it --image nicolaka/netshoot testnet "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bash")]),t._v("\n\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("curl")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("clusterIP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 마크업 출력")]),t._v("\n")])])]),s("h3",{attrs:{id:"nodeport-타입-서비스-사용"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nodeport-타입-서비스-사용"}},[t._v("#")]),t._v(" NodePort 타입 서비스 사용")]),t._v(" "),s("ul",[s("li",[t._v("NodePort 타입 서비스는 ClusterIP에서 "),s("strong",[t._v("서비스 이름, 타입 설정, 접속 포트")]),t._v(" 이외에는 설정이 같음")])]),t._v(" "),s("h3",{attrs:{id:"loadbalancer-타입-서비스-사용하기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loadbalancer-타입-서비스-사용하기"}},[t._v("#")]),t._v(" LoadBalancer 타입 서비스 사용하기")]),t._v(" "),s("ul",[s("li",[t._v("LoadBalancer 타입 서비스는 ClusterIP에서 "),s("strong",[t._v("서비스 이름, 타입 설정")]),t._v(" 이외에는 설정이 같음")])]),t._v(" "),s("h3",{attrs:{id:"externalname-타입-서비스-사용하기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#externalname-타입-서비스-사용하기"}},[t._v("#")]),t._v(" ExternalName 타입 서비스 사용하기")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Service\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" externalname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("service\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ExternalName "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 필드값 설정")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("externalName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" google.com "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 연결하려는 외부 도메인 값 설정")]),t._v("\n")])])]),s("br"),t._v(" "),s("h2",{attrs:{id:"헤드리스-서비스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#헤드리스-서비스"}},[t._v("#")]),t._v(" 헤드리스 서비스")]),t._v(" "),s("ul",[s("li",[s("code",[t._v(".spec.clusterIP")]),t._v(" 필드 값을 None으로 설정하면 클러스터 IP가 없는 서비스를 만들 수 있음")]),t._v(" "),s("li",[t._v("로드밸런싱 또는 단일 서비스 IP가 필요 없을 때 사용가능")]),t._v(" "),s("li",[t._v("헤드리스 서비스에 셀렉터를 설정하면 쿠버네티스 API로 확인 가능한 엔드포인트와 서비스와 연결된 파드를 직접 가리키는 DNS A 레코드가 생성됨")]),t._v(" "),s("li",[t._v("셀렉터가 없더라도 DNS 시스템은 ExternalName 타입의 서비스에서 사용할 CNAME 레코드가 생성됨")])]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"kube-proxy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kube-proxy"}},[t._v("#")]),t._v(" kube-proxy")]),t._v(" "),s("ul",[s("li",[t._v("쿠버네티스에서 서비스를 만들었을 때 클러스터 IP나 노드 포트로 접근할수 있게 만들어 실제 조작하는 컴포넌트")]),t._v(" "),s("li",[t._v("쿠버네티스 클러스터의 노드마다 실행되면서 클러스터 내부 IP로 연결하려는 요청을 적절한 파드로 전달")]),t._v(" "),s("li",[t._v("kube-proxy가 네트워크를 관리하는 방법은 "),s("strong",[t._v("userspace, iptables, IPVS가 있음")])])]),t._v(" "),s("h3",{attrs:{id:"userspace-모드"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#userspace-모드"}},[t._v("#")]),t._v(" userspace 모드")]),t._v(" "),s("ul",[s("li",[t._v("클라이언트에서 서비스의 클러스터 IP를 통해 어떤 요청을 하면 iptables을 거쳐서 kube-proxy 요청을 받고, 서비스의 클러스터 IP는 연결되어야 하는 적절한 파드로 연결해줌")]),t._v(" "),s("li",[t._v("요청을 파드들에 나눠 줄 때는 라운드 로빈 방식 사용")])]),t._v(" "),s("h3",{attrs:{id:"i-tables-모드"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#i-tables-모드"}},[t._v("#")]),t._v(" i-tables 모드")]),t._v(" "),s("ul",[s("li",[t._v("userspace 모드와 다른 점은 kube-proxy가 iptables를 관리하는 역할만 하고 직접 클라이언트에서 트랙픽을 받지 않음")]),t._v(" "),s("li",[t._v("클라이언트에서 오는 모든 요청은 iptables을 거쳐서 파드로 직접 전달(userspace 모드보다 요청 처리 성능이 좋음)")]),t._v(" "),s("li",[t._v("userspace 모드에서 연결 요청이 실패하면 재시도하지만, i-tables 모드에서는 요청이 실패")]),t._v(" "),s("li",[t._v("컨테이너에 readinessProbe가 설정되었고 그에 따른 헬스 체크가 정상적으로 되어야 연결 요청이 이루어짐")])]),t._v(" "),s("h3",{attrs:{id:"ipvs-ip-virtual-server-모드"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipvs-ip-virtual-server-모드"}},[t._v("#")]),t._v(" IPVS(IP Virtual Server) 모드")]),t._v(" "),s("ul",[s("li",[t._v("리눅스 커널에 있는 L4 로드밸런싱 기술")]),t._v(" "),s("li",[t._v("커널 공간에 동작하고 데이터 구조를 해시 테이블로 저장하기 때문에 iptables 모드보다 빠르고 좋은 성능을 냄")])]),t._v(" "),s("h4",{attrs:{id:"로드밸런싱-알고리즘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#로드밸런싱-알고리즘"}},[t._v("#")]),t._v(" 로드밸런싱 알고리즘")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("rr(round-robin):")]),t._v(" 프로세스 사이에 우선순위를 두지 않고 순서와 시간 단위로 CPU 할당")]),t._v(" "),s("li",[s("strong",[t._v("lc(least connection):")]),t._v(" 접속 개수가 가장 적은 서버 선택")]),t._v(" "),s("li",[s("strong",[t._v("dh(destination hashing):")]),t._v(" 목적지 IP 주소로 해시값을 계산해 분산할 실제 서버 선택")]),t._v(" "),s("li",[s("strong",[t._v("sh(source hashing):")]),t._v(" 출발지 IP 주소로 해시값을 계산해 분산할 실제 서버 선택")]),t._v(" "),s("li",[s("strong",[t._v("sed(shorts expected deplay):")]),t._v(" 응답 속도가 가장 빠른 서버 선택")]),t._v(" "),s("li",[s("strong",[t._v("nq(never queue):")]),t._v(" sed와 비슷하지만 활성 접속 개수가 0인 서버를 가장 먼저 선택")])]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"referenses"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#referenses"}},[t._v("#")]),t._v(" Referenses")]),t._v(" "),s("ul",[s("li",[t._v("쿠버네티스 입문 - 90가지 예제로 배우는 컨테이너 관리 자동화 표준 / 동양북스")])])],1)}),[],!1,null,null,null);a.default=r.exports}}]);